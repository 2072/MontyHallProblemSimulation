/**
 * Copyright (c) 2025 John Wellesz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import org.scalatest.funsuite.AnyFunSuite
import org.scalatest.matchers.should.Matchers

import scala.util.Random

// The following tests were generated by an AI after feeding it the human-coded main file code, a few successive
// prompts were necessary to get it right + a few modifications and clarification, but it made 80% of the job.
class mainTest extends AnyFunSuite with Matchers {

  // Just a few helper extensions functions to make our tests even more readable
  // (allows to write result wins and result loses when true and false, respectively)
  import language.postfixOps
  extension (b: Boolean)
    inline infix def wins: Boolean = b
    inline def loses: Boolean = !b

  // Make tests reproducible by forcing a fixed seed to the game random number generator
  MontyHallGame.gameRandomGen.synchronized {
    MontyHallGame.gameRandomGen.setSeed(42L)
  }

  test("playRoundOne returns a valid door different from initial choice") {
    val testRng = new Random()
    for (_ <- 0 until 1000) do {
      val pick = testRng.between(0, 3) // pick a random door
      val game = MontyHallGame(3, candidate1stChoice = pick)
      val remaining = game.playRoundOne

      remaining should (be >= 0 and be < 3)
      remaining should not equal pick
    }
  }

  test("When player initially picked the car → switching loses") {
    val testRng = new Random()
    for (_ <- 0 until 1000) do { // do this test 1000 times with a random pick each time
      val pick = testRng.between(0, 3)

      val game = MontyHallGame(3, candidate1stChoice = pick)

      val notSwitching = game.playRoundTwoKeeping1stChoice

      val switching = game.playRoundTwoWithNewChoice(Some(game.playRoundOne))

      if (notSwitching wins) {
        // Player had it right → switching must lose
        (switching loses) shouldBe true
      }
    }
  }

  test("When player initially picked a goat → switching wins") {
    val testRng = new Random()
    for (_ <- 0 until 1000) do { // do this test 1000 times with a random pick each time
      val pick = testRng.between(0, 3)

      val game = MontyHallGame(3, candidate1stChoice = pick)

      val notSwitching = game.playRoundTwoKeeping1stChoice

      val switching = game.playRoundTwoWithNewChoice(Some(game.playRoundOne))

      if (notSwitching loses) {
        // Player had it right → switching must lose
        (switching wins) shouldBe true
      }
    }
  }

  test("Classic 3-door Monty Hall: switching wins ~66.7% of the time") {
    val trials = 20000
    // use fix choice for reproducibility
    // create 20000 games
    val games = (0 until trials).map(_ => MontyHallGame(3, candidate1stChoice = 1))

    // count the number of games where playing with the switching strategy won
    val switchingWonGamesNumber = games.count (game =>
      game.playRoundTwoWithNewChoice(Some(game.playRoundOne)) wins
    )

    val switchStrategyWinRate = switchingWonGamesNumber.toDouble / trials
    println(f"Switching win rate (20,000 games): $switchStrategyWinRate%.4f (expected ~0.6667)")

    switchStrategyWinRate should be >= 0.65
    switchStrategyWinRate should be <= 0.69
  }

  test("Generalized: 100 doors → switching should win ~99% of the time") {
    val trials = 5000
    // use fix choice for reproducibility
    // create 20000 games
    val games = (0 until trials).map(_ => MontyHallGame(100, candidate1stChoice = 0))

    // count the number of games where playing with the switching strategy won
    val switchWins = games.count(game =>
      game.playRoundTwoWithNewChoice(Some(game.playRoundOne)) wins
    )

    val switchStrategyWinRate = switchWins.toDouble / trials
    println(f"100-door switching win rate: $switchStrategyWinRate%.4f (expected ~0.99)")

    switchStrategyWinRate should be > 0.98
  }

  test("Monty never reveals player's choice or the car — verified through behavior") {
    def montyFollowsRules(game: MontyHallGame): Boolean = {
      val revealedDoors = game.montyRevealedGoats
      val remainingDoor = game.playRoundOne
      val player1stChoice = game.candidate1stChoice

      // 1. Monty never opens player's door
      val doesNotOpenPlayerDoor = !revealedDoors.contains(player1stChoice)

      // 2. Exactly one other door remains closed
      val exactlyOneOtherClosed = (0 until game.doorNum).count { d =>
        d != player1stChoice && !revealedDoors.contains(d)
      } == 1

      // 3. If player was wrong → the remaining door must be the car
      val ifPlayerWrongThenRemainingIsCar = {


        if (game.playRoundTwoWithNewChoice(o_newChoice = None) loses) { // the not-switching strategy loses
          game.playRoundTwoWithNewChoice(Some(remainingDoor)) wins // then using the switching strategy wins
        } else true
      }

      doesNotOpenPlayerDoor && exactlyOneOtherClosed && ifPlayerWrongThenRemainingIsCar
    }

    val testRng = new Random()

    val allGames = (0 until 2000).map(_ =>
      MontyHallGame(10, candidate1stChoice = testRng.between(0, 10))
    )

    allGames.forall(montyFollowsRules) shouldBe true
  }
}