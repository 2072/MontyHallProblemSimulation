/**
 * CCopyright (c) 2025 John Wellesz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import org.scalatest.funsuite.AnyFunSuite
import org.scalatest.matchers.should.Matchers

import scala.util.Random

// The following tests where generated by an AI after feeding it the human-coded main file code, a few successive
// prompts were necessary to get it right + a few modifications, but it made 95% of the job
class mainTest extends AnyFunSuite with Matchers {
  // Make tests reproducible
  MontyHallGame.gameRandomGen.synchronized {
    MontyHallGame.gameRandomGen.setSeed(42L)
  }

  test("playRoundOne returns a valid door different from initial choice") {
    val testRng = new Random()
    for (_ <- 0 until 1000) do {
      val pick = testRng.between(0, 3)
      val game = MontyHallGame(3, candidate1stChoice = pick)
      val remaining = game.playRoundOne

      remaining should (be >= 0 and be < 3)
      remaining should not equal pick
    }
  }

  test("When player initially picked the car → switching loses") {
    val testRng = new Random()
    for (_ <- 0 until 1000) do {
      val pick = testRng.between(0, 3)

      val game = MontyHallGame(3, candidate1stChoice = pick)

      val stuckWins = game.playRoundTwo(None)

      val switchedWins = game.playRoundTwo(Some(game.playRoundOne))

      if (stuckWins) {
        // Player had it right → switching must lose
        switchedWins shouldBe false
      }
    }
  }

  test("When player initially picked a goat → switching wins") {
    val testRng = new Random()

    val games = (0 until 1000).map(_ =>
      MontyHallGame(3, candidate1stChoice = testRng.between(0, 3))
    )

    games.foreach { game =>
      val stuckWins = game.playRoundTwo(None)
      val switchedWins = game.playRoundTwo(Some(game.playRoundOne))

      if (!stuckWins) {
        // Player was wrong initially → switching MUST win
        switchedWins shouldBe true
      }
    }
  }

  test("Classic 3-door Monty Hall: switching wins ~66.7% of the time") {
    val trials = 20000
    // use fix choice for reproducibility
    val games = (0 until trials).map(_ => MontyHallGame(3, candidate1stChoice = 1))

    val switchWins = games.count { g =>
      g.playRoundTwo(Some(g.playRoundOne))
    }

    val winRate = switchWins.toDouble / trials
    println(f"Switching win rate (20,000 games): $winRate%.4f (expected ~0.6667)")

    winRate should be >= 0.65
    winRate should be <= 0.69
  }

  test("Generalized: 100 doors → switching should win ~99% of the time") {
    val trials = 5000
    // use fix choice for reproducibility
    val games = (0 until trials).map(_ => MontyHallGame(100, candidate1stChoice = 0))

    val switchWins = games.count(g => g.playRoundTwo(Some(g.playRoundOne)))

    val winRate = switchWins.toDouble / trials
    println(f"100-door switching win rate: $winRate%.4f (expected ~0.99)")

    winRate should be > 0.98
  }

  test("Monty never reveals player's choice or the car — verified through behavior") {
    def montyFollowsRules(game: MontyHallGame): Boolean = {
      val revealed = game.montyRevealedGoats
      val remaining = game.playRoundOne
      val playerChoice = game.candidate1stChoice

      // 1. Monty never opens player's door
      val doesNotOpenPlayerDoor = !revealed.contains(playerChoice)

      // 2. Exactly one other door remains closed
      val exactlyOneOtherClosed = (0 until game.doorNum).count { d =>
        d != playerChoice && !revealed.contains(d)
      } == 1

      // 3. If player was wrong → the remaining door must be the car
      val ifPlayerWrongThenRemainingIsCar = {
        val playerWasWrong = !game.playRoundTwo(None)
        if (playerWasWrong) {
          game.playRoundTwo(Some(remaining))
        } else true
      }

      doesNotOpenPlayerDoor && exactlyOneOtherClosed && ifPlayerWrongThenRemainingIsCar
    }

    val testRng = new Random()

    val allGames = (0 until 2000).map(_ =>
      MontyHallGame(10, candidate1stChoice = testRng.between(0, 10))
    )

    allGames.forall(montyFollowsRules) shouldBe true
  }

  test("Sticking wins if and only if first guess was correct") {
    val testRng = new Random()

    (0 until 1000).foreach { _ =>
      val game = MontyHallGame(5, candidate1stChoice = testRng.between(0, 5))

      val stickWins = game.playRoundTwo(None)

      stickWins shouldBe (game.candidate1stChoice == {
        // Trick: if switching loses → player had it right
        val switchResult = game.playRoundTwo(Some(game.playRoundOne))

        if (!switchResult)
          game.candidate1stChoice
        else
          game.playRoundOne
      })
    }
  }
}